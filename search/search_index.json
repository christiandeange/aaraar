{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p><code>aaraar</code> is a Gradle plugin that assists in embedding other dependencies directly into your published artifact. The plugin can be applied to any module that is published as an <code>aar</code> or a <code>jar</code> file, and includes some handy features such as:</p> <ul> <li>Embedding dependencies directly into your <code>jar</code> or <code>aar</code> file</li> <li>Shading classes to rename or delete them</li> <li>Stripping <code>META-INF</code> files</li> </ul> <p><code>aaraar</code> is simple to use with the most common publishing plugins, including the Maven Publish Plugin and the Gradle Maven Publish Plugin, but advanced configuration is still available for those with a more custom publishing pipeline.</p> <p>Visit Installation to get started.</p>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#version-015","title":"Version 0.1.5","text":"<p>2026-01-30</p> <ul> <li>Fix: Configure a default value for the <code>PackageJarTask.packagerFactory</code> task property on JVM projects.</li> </ul>"},{"location":"changelog/#version-014","title":"Version 0.1.4","text":"<p>2026-01-17</p> <ul> <li>New: Expose property to allow custom <code>Packager</code> implementations for more customizability during packaging.</li> <li>Update: Move post-processor factory classes to <code>sh.christian.aaraar.packaging</code> package:<ul> <li><code>class sh.christian.aaraar.packaging.ApiJarProcessor</code></li> <li><code>class sh.christian.aaraar.packaging.ArtifactArchiveProcessor</code></li> <li><code>fun sh.christian.aaraar.packaging.artifactArchiveProcessorFromClassName</code></li> </ul> </li> <li>Fix: Properly generate <code>kotlin.Metadata</code> annotations for <code>api.jar</code> files.</li> </ul>"},{"location":"changelog/#version-013","title":"Version 0.1.3","text":"<p>2025-11-18</p> <ul> <li>New: Expose more useful public constructors and factory methods for core data models.</li> <li>New: Implement <code>equals()</code> and <code>hashCode()</code> for core data models.</li> </ul>"},{"location":"changelog/#version-012","title":"Version 0.1.2","text":"<p>2025-08-21</p> <ul> <li>New: Allow resource files to be relocated using shading rules.</li> <li>Update: Make packaging tasks compatible with Gradle configuration caching.</li> <li>Update: Allow class files to be deleted via packaging option rules only when it ends with <code>.class</code>.</li> <li>Fix: Ensure that internal/inline classes are properly relocated by shading rules.</li> <li>Fix: Correct the format of <code>public.txt</code> files written to AAR files.</li> </ul>"},{"location":"changelog/#version-011","title":"Version 0.1.1","text":"<p>2025-03-27</p> <ul> <li>Fix: Update Gradle attributes on incoming/outgoing artifact configurations.</li> </ul>"},{"location":"changelog/#version-010","title":"Version 0.1.0","text":"<p>2025-02-19</p> <ul> <li>New: Create embedTree configurations to allow consumers to embed an entire dependency tree into a merged artifact.</li> <li>New: Apply shading rules to <code>ServiceLoader</code> provider configuration files.</li> <li>New: Apply shading rules to <code>.kotlin_module</code> files.</li> <li>Update: Allow aaraar artifact to be used as dependency of other projects.</li> <li>Fix: Resource exclusions should not apply to class files.</li> </ul>"},{"location":"changelog/#version-0018","title":"Version 0.0.18","text":"<p>2024-12-11</p> <ul> <li>Update: Set the <code>org.gradle.jvm.environment</code> capability on embed configurations.</li> <li>Update: Improvements to <code>api.jar</code> generation:<ul> <li>Expose Kotlin <code>@Metadata</code> annotation property.</li> <li>Automatically update Kotlin metadata when member changes.</li> <li><code>Classpath.get()</code> returns a virtual definition if not found.</li> </ul> </li> <li>Fix: Android resources from embedded dependencies could not be resolved.</li> </ul>"},{"location":"changelog/#version-0017","title":"Version 0.0.17","text":"<p>2024-08-10</p> <ul> <li>New: Support for adding post-processors for custom operations on the merged archive.<ul> <li>See packaging guide for info on configuration.</li> </ul> </li> <li>Update: Extract interfaces for <code>Classpath</code> and related classes to expose only immutable methods.</li> <li>Fix: Avoid overwriting modifiers from source classes when generating <code>api.jar</code> files.</li> </ul>"},{"location":"changelog/#version-0016","title":"Version 0.0.16","text":"<p>2024-08-02</p> <ul> <li>Update: Modularize Gradle packaging code to allow for reuse in other projects.</li> <li>Fix: Avoid exception when combining packaging option rules for Android projects.</li> </ul>"},{"location":"changelog/#version-0015","title":"Version 0.0.15","text":"<p>2024-06-24</p> <ul> <li>New: Support custom shading strategies in core utilities module.</li> <li>New: Support for the entire <code>packaging</code> configuration when merging and packaging Android projects.</li> <li>Update: Changes to <code>api.jar</code> generation:</li> <li>New: Support for reading and writing the class file version.</li> <li>Note: Adding/modifying enum classes is not supported, and will be ignored.</li> </ul>"},{"location":"changelog/#version-0014","title":"Version 0.0.14","text":"<p>2024-03-10</p> <ul> <li>Update: Shading configuration syntax now supports applying one rule to multiple scopes.</li> <li>Update: Allows disabling <code>api.jar</code> generation by providing an <code>ApiJarProcessor.Factory.None</code> by default.</li> <li>Update: <code>api.jar</code> generation now allows reading and writing annotations that are not visible via reflection.</li> </ul>"},{"location":"changelog/#version-0013","title":"Version 0.0.13","text":"<p>2024-02-27</p> <ul> <li>New: Support for creating a custom <code>api.jar</code> in an AAR file.<ul> <li>This optional jar is used by the IDE as the autocomplete source, as well as what consumers compile against.</li> <li>Does not affect which classes and class members are executable at runtime.</li> <li>Provides an integration point for complete customization to add/remove classes, rename methods, and more.</li> <li>See packaging guide for info on configuration.</li> </ul> </li> </ul>"},{"location":"changelog/#version-0012","title":"Version 0.0.12","text":"<p>2024-02-07</p> <ul> <li>New: Support for limiting shading rules to a particular scope.<ul> <li>See shading guide for info on configuration and syntax.</li> </ul> </li> <li>New: Added <code>addPrefix()</code> shorthand method for shading to add a prefix to each class package.</li> </ul>"},{"location":"changelog/#version-0011","title":"Version 0.0.11","text":"<p>2024-02-01</p> <ul> <li>Update: The <code>keepMetaFiles</code> configuration option now defaults to <code>true</code>.</li> <li>Fix: Resolve issue opening/creating archive files in Windows.</li> </ul>"},{"location":"changelog/#version-0010","title":"Version 0.0.10","text":"<p>2023-09-02</p> <ul> <li>New: Generate Dokka documentation.</li> <li>New: Hosted setup guide at https://aaraar.christian.sh.</li> <li>New: Support for Java projects!<ul> <li>The same <code>sh.christian.aaraar</code> plugin can be applied to Java or Kotlin libraries that produce a <code>jar</code> file instead.</li> <li>Configuration is also done through the same <code>aaraar</code> Gradle extension.</li> <li>See publishing guide for details on how to publish embedded <code>jar</code> files.</li> </ul> </li> </ul>"},{"location":"changelog/#version-009","title":"Version 0.0.9","text":"<p>2023-08-10</p> <ul> <li>New: Support for merging navigation.json file.</li> <li>New: Preserve aar-metadata.properties file.</li> <li>Fix: Continue using APIs that are compatible with AGP7 and Java 11.</li> </ul>"},{"location":"changelog/#version-008","title":"Version 0.0.8","text":"<p>2023-06-01</p> <ul> <li>New: Run aaraar packaging during assemble pipeline.<ul> <li>Developers can choose which variants enable aaraar packaging using the existing <code>aaraar</code> extension: <pre><code>aaraar {\n  isEnabledForVariant { it.name == \"release\" }\n}\n</code></pre></li> </ul> </li> <li>Update: Support for consuming Gradle Module Metadata.</li> <li>Update: Support for Android Gradle Plugin 8.</li> </ul>"},{"location":"changelog/#version-007","title":"Version 0.0.7","text":"<p>2023-03-29</p> <ul> <li>Fix: Add missing \"usage\" attribute to configuration.</li> </ul>"},{"location":"changelog/#version-006","title":"Version 0.0.6","text":"<p>2023-03-13</p> <ul> <li>Fix: Capture missing API element modules.</li> </ul>"},{"location":"changelog/#version-005","title":"Version 0.0.5","text":"<p>2023-02-28</p> <ul> <li>New: Respect <code>packagingOptions.resources.excludes</code> rules configured for project.<ul> <li>If any file globs are specified to be excluded, those files should always be deleted from the packaged aar.</li> </ul> </li> </ul>"},{"location":"changelog/#version-004","title":"Version 0.0.4","text":"<p>2023-02-10</p> <ul> <li>Update: Flatten and merge all library dependency jars into single <code>classes.jar</code>.</li> <li>Update: Make core data models have internal constructors but public property access.</li> <li>Fix: Add Usage attribute to aar publishing configuration.</li> </ul>"},{"location":"changelog/#version-003","title":"Version 0.0.3","text":"<p>2023-02-03</p> <ul> <li>Fix: Support for compiling resources with custom xmlns namespaces.</li> </ul>"},{"location":"changelog/#version-002","title":"Version 0.0.2","text":"<p>2023-01-29</p> <ul> <li>New: Updated release pipeline and CI builds.</li> <li>Fix: Create extension as soon as plugin is applied.</li> </ul>"},{"location":"changelog/#version-001","title":"Version 0.0.1","text":"<p>2023-01-24</p> <ul> <li>Initial release.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>The plugin only needs to be applied to modules you intend to publish as artifacts.</p> KotlinGroovy <pre><code>// build.gradle.kts\n\nplugins {\n  id(\"sh.christian.aaraar\") version \"0.1.5\"\n}\n</code></pre> <pre><code>// build.gradle\n\nplugins {\n  id(\"sh.christian.aaraar\") version \"0.1.5\"\n}\n</code></pre>"},{"location":"installation/#android","title":"Android","text":"<p>For Android modules, aaraar is configured to run automatically as part of the assemble pipeline for all variants, unless configured otherwise via the provided <code>aaraar</code> extension. It is recommended that you only enable aaraar for variant(s) you intend to publish.</p> <pre><code>aaraar {\n  isEnabledForVariant { variant -&gt;\n    variant.name == \"release\"\n  }\n}\n</code></pre>"},{"location":"installation/#jvm","title":"JVM","text":"<p>By default, the <code>packageJar</code> task will overwrite the output of the <code>jar</code> task with the merged jar file, but this can be customized to suit your needs by changing the <code>PackageJar.outputJar</code> task output file property.</p> KotlinGroovy <pre><code>tasks.named&lt;PackageJarTask&gt;(\"packageJar\") {\n  isEnabled = providers.gradleProperty(\"enablePublishing\").map { it.toBoolean() }.getOrElse(false)\n\n  outputJar.set(project.layout.buildDirectory.file(\"artifact-all.jar\"))\n}\n\n// Run via ./gradlew -PenablePublishing=true [task_name]\n</code></pre> <pre><code>tasks.named(\"packageJar\", PackageJarTask) {\n  setEnabled(providers.gradleProperty(\"enablePublishing\").map { it.toBoolean() }.getOrElse(false))\n\n  outputJar = project.layout.buildDirectory.file(\"artifact-all.jar\")\n}\n\n// Run via ./gradlew -PenablePublishing=true [task_name]\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>Copyright 2025 Christian De Angelis\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"packaging/","title":"Packaging","text":"<p>The aaraar Gradle plugin can be applied to any module that is published as an <code>aar</code> or a <code>jar</code> file. For Android modules, the following entries in an <code>aar</code> file are recognized for merging:</p> <ul> <li>Class files</li> <li>Android manifests</li> <li>Android resources</li> <li>Android assets</li> <li>Local <code>jar</code> libraries</li> <li>Native JNI libraries</li> <li>Proguard consumer rules</li> <li>Lint consumer checks</li> <li>Navigation graphs</li> <li><code>api.jar</code> files</li> <li><code>aar</code> metadata</li> </ul>"},{"location":"packaging/#gradle-configuration","title":"Gradle Configuration","text":"<p>The Gradle plugin exposes two configurations for you to include dependencies in a module's packaged output:</p> Configuration Description <code>embed</code> Include only this dependency in the packaged output. <code>embedTree</code> Include this dependency and all of its own runtime dependencies in the packaged output. KotlinGroovy <pre><code>dependencies {\n  compileOnly(project(\":internal\"))\n  embed(project(\":internal\"))\n}\n</code></pre> <pre><code>dependencies {\n  compileOnly project(\":internal\")\n  embed project(\":internal\")\n}\n</code></pre> <p>Declaring an embedded dependency only includes it in the packaged output, it does not make that dependency available during compilation! If you wish to reference any classes in the embedded dependency in your Gradle module, you will also need to declare it as a <code>compileOnly</code> dependency as shown above. You can also configure this automatically by making embedded dependencies available during compilation:</p> KotlinGroovy <pre><code>dependencies {\n  embed(project(\":internal\"))\n}\n\nconfigurations.compileOnly.configure {\n  extendsFrom(configurations[\"embed\"])\n  extendsFrom(configurations[\"embedTree\"])\n}\n</code></pre> <pre><code>dependencies {\n  embed project(\":internal\")\n}\n\nconfigurations.compileOnly {\n  extendsFrom configurations.embed\n  extendsFrom configurations.embedTree\n}\n</code></pre> <p>Adding embedded dependencies to <code>compileOnly</code> is intentional; if they are also added as <code>implementation</code> or <code>api</code> dependencies, they will show up in the published POM file, causing duplicated class conflicts for downstream consumers of your merged artifact!</p> <p>In Android modules, embed configurations can also be declared for individual build types, including custom ones:</p> KotlinGroovy <pre><code>android {\n  buildTypes {\n    create(\"publish\") {\n      initWith(buildTypes.getByName(\"release\"))\n      matchingFallbacks += \"release\"\n    }\n  }\n}\n\ndependencies {\n  compileOnly(project(\":internal\"))\n  publishEmbed(project(\":internal\"))\n}\n</code></pre> <pre><code>android {\n  buildTypes {\n    publish {\n      initWith release\n      matchingFallbacks += \"release\"\n    }\n  }\n}\n\ndependencies {\n  compileOnly project(\":internal\")\n  publishEmbed project(\":internal\")\n}\n</code></pre> <p><code>embedTree</code> is necessary if you wish to embed a dependency that has its own transitive runtime dependencies, especially for third-party dependencies. If such a dependency was included in <code>embed</code> instead, projects that consume the merged artifact will be responsible for providing their own dependencies at runtime for the missing dependencies. The difference between <code>embed</code> and <code>embedTree</code> can be seen when running a Gradle task to visualize the dependency tree for a given configuration:</p> embedembedTree KotlinGroovy <pre><code>dependencies {\n  releaseEmbed(\"com.google.crypto.tink:tink-android:1.16.0\")\n}\n</code></pre> <pre><code>dependencies {\n  releaseEmbed 'com.google.crypto.tink:tink-android:1.16.0'\n}\n</code></pre> <pre><code>$ ./gradlew :app:dependencies --configuration releaseEmbedClasspath\n\nreleaseEmbedClasspath\n\\--- com.google.crypto.tink:tink-android:1.16.0\n</code></pre> KotlinGroovy <pre><code>dependencies {\n  releaseEmbedTree(\"com.google.crypto.tink:tink-android:1.16.0\")\n}\n</code></pre> <pre><code>dependencies {\n  releaseEmbedTree 'com.google.crypto.tink:tink-android:1.16.0'\n}\n</code></pre> <pre><code>$ ./gradlew :app:dependencies --configuration releaseEmbedClasspath\n\nreleaseEmbedClasspath\n\\--- com.google.crypto.tink:tink-android:1.16.0\n +--- androidx.annotation:annotation-jvm:1.8.2\n |    \\--- org.jetbrains.kotlin:kotlin-stdlib:1.7.10\n |         +--- org.jetbrains.kotlin:kotlin-stdlib-common:1.7.10\n |         \\--- org.jetbrains:annotations:13.0\n +--- com.google.code.findbugs:jsr305:3.0.2\n +--- com.google.code.gson:gson:2.10.1\n \\--- com.google.errorprone:error_prone_annotations:2.22.0\n</code></pre>"},{"location":"packaging/#meta-inf-files","title":"META-INF files","text":"<p>You can also let the plugin know whether to strip all <code>META-INF/</code> files from the packaged output file. By default it keeps them all, but this can be configured via the plugin extension:</p> KotlinGroovy <pre><code>aaraar {\n  // Strip all META-INF/ files from the merged file\n  keepMetaFiles.set(false)\n}\n</code></pre> <pre><code>aaraar {\n  // Strip all META-INF/ files from the merged file\n  keepMetaFiles = false\n}\n</code></pre>"},{"location":"packaging/#packaging-options-for-android-libraries","title":"Packaging Options for Android Libraries","text":"<p>The <code>packaging</code> block in an Android module's build script is used to handle the packaging of resources and JNI libraries. This plugin also uses those same rules to configure handling of resources and JNI libraries merge conflicts when merging multiple aar files together.</p>"},{"location":"packaging/#post-processing","title":"Post-Processing","text":"<p>The plugin allows you to register custom processors that will be executed after the merged archive has been created. This can be useful for logging, validation, or applying other operations that you may want to perform on the merged archive. To register a processor, you must first create a factory that will be used to create instances of your custom processor via the plugin extension:</p> KotlinGroovy <pre><code>aaraar {\n  addPostProcessorFactory(ClassLoggingProcessorFactory())\n}\n</code></pre> <pre><code>aaraar {\n  addPostProcessorFactory(new ClassLoggingProcessorFactory())\n}\n</code></pre> <p>Note that your factory must be <code>Serializable</code>.</p> <p>The factory can also be registered by passing in only the class name, which will be used to reflective instantiate an instance at task execution. This is useful if your factory is not available on the Gradle buildscript classpath. In doing so, you must ensure that your factory has a public no-arg constructor so that it can be properly created:</p> KotlinGroovy <pre><code>aaraar {\n  addPostProcessorFactory(\"com.example.gradle.ClassLoggingProcessorFactory\")\n}\n</code></pre> <pre><code>aaraar {\n  addPostProcessorFactory(\"com.example.gradle.ClassLoggingProcessorFactory\")\n}\n</code></pre> <p>Processors are executed in the order they are registered. The factory interface is very straightforward and only defines a <code>create()</code> method for you to implement. This method should return an instance of your custom <code>ArtifactArchiveProcessor</code> implementation that will be executed on the merged archive.</p> KotlinGroovy <pre><code>class ClassLoggingProcessor : ArtifactArchiveProcessor {\n    override fun process(archive: ArtifactArchive): ArtifactArchive {\n        println(\"Merged archive contains: ${archive.classes.archive.count()} classes.\")\n        return archive\n    }\n}\n</code></pre> <pre><code>class ClassLoggingProcessor implements ArtifactArchiveProcessor {\n    @Override\n    ArtifactArchive process(@NotNull ArtifactArchive archive) {\n        println \"Merged archive contains: ${archive.classes.archive.size()} classes.\"\n        return archive\n    }\n}\n</code></pre>"},{"location":"packaging/#api-jar-for-android-libraries","title":"API Jar for Android Libraries","text":"<p>The <code>api.jar</code> file is an optional element inside an aar archive that helps developers using the library understand its exposed classes, methods, and functionalities. When this file exists in an aar, it will be used it as the source of truth for which members can be referenced at compilation time.</p> <p>Generating a custom <code>api.jar</code> file can be used to hide certain public members from IDE autocomplete, though they can still be referenced and invoked via reflection at runtime as per usual.</p> <p>Generating this file begins with registering an <code>ArtifactArchiveProcessor.Factory</code> factory to create a subclass of <code>ApiJarProcessor</code>. The processor implementation is where the <code>api.jar</code> transformation occurs. When enabled, it is provided with a representation of the current set of classes defined in the merged aar archive, as well as a reference to the merged archive itself. While the archive is immutable, the classpath provided is mutable and supports a variety of transformations, including but not limited to:</p> <ul> <li>Removing existing classes and class members (constructors, methods, and fields).</li> <li>Defining entirely new classes with custom members.</li> <li>Renaming classes and class members or modifying their access visibility.</li> <li>Adding or removing annotations on classes and class members.</li> </ul> <p>An example implementation can be seen below, which is used to remove a public class and a public method that are both meant for internal use only:</p> KotlinGroovy <pre><code>class MyApiJarProcessor : ApiJarProcessor {\n  override fun processClasspath(aarArchive: AarArchive, classpath: MutableClasspath) {\n    // Remove internal class\n    classpath.removeClass(\"com.example.TerminalSdkInternal\")\n\n    // Remove internal method on public class\n    val fooClass = classpath.get(\"com.example.TerminalSdk\")\n    fooClass.methods = fooClass.methods.filter { !it.name.contains(\"internal\", ignoreCase = true) }\n  }\n}\n</code></pre> <pre><code>class MyApiJarProcessor implements ApiJarProcessor {\n  @Override\n  void processClasspath(@NotNull AarArchive aarArchive, @NotNull MutableClasspath classpath) {\n    // Remove internal class\n    classpath.removeClass(\"com.example.TerminalSdkInternal\")\n\n    // Remove internal method on public class\n    def fooClass = classpath.get(\"com.example.TerminalSdk\")\n    fooClass.methods = fooClass.methods.findAll { !it.name.containsIgnoreCase(\"internal\") }\n  }\n}\n</code></pre> <p>Further documentation for the kind of transformations available can be found by referencing API documentation for the <code>sh.christian.aaraar.model.classeditor</code> package.</p> <p>Modifying Enums</p> <p>At this time, creating new enum classes or modifications to existing enum classes will be ignored.</p> <p>Modifying Parameter Names</p> <p>By default, parameter name metadata is not included in class files. If you wish to include parameter names in the compiled <code>classes.jar</code> and <code>api.jar</code> files, you must compile your library with additional flags in order to embed this data in your compiled class files:</p> KotlinGroovy <pre><code>// build.gradle.kts\n\ntasks.withType&lt;KotlinCompile&gt;().configureEach {\n  compilerOptions.freeCompilerArgs.add(\"-java-parameters\")\n}\ntasks.withType&lt;JavaCompile&gt;().configureEach {\n  options.compilerArgs.add(\"-parameters\")\n}\n</code></pre> <pre><code>// build.gradle\n\ntasks.withType(KotlinCompile).configureEach {\n  compilerOptions.freeCompilerArgs += \"-java-parameters\"\n}\ntasks.withType(JavaCompile).configureEach {\n  options.compilerArgs += \"-parameters\"\n}\n</code></pre>"},{"location":"packaging/#packager-configuration","title":"Packager configuration","text":"<p>The plugin uses a \"packager\" to handle merging of archive files. The packager is responsible for facilitating a few different tasks during the lifecycle of packaging the final artifact:</p> <ul> <li>Processing the set of input archives.</li> <li>Applying shading rules to the input archives.</li> <li>Merge the input archives into a single output archive.</li> <li>Applying any post-processing steps to the merged archive.</li> </ul> <p><code>DefaultPackager</code> is the default implementation, which provides standard behaviour to shading, merging, and applying post-processor factories to the merged archive. However, you can also provide your own custom packager implementation by creating a <code>Packager</code> implementation and registering a factory for it via the plugin extension:</p> KotlinGroovy <pre><code>aaraar {\n  packagerFactory.set(MyPackagerFactory())\n}\n</code></pre> <pre><code>aaraar {\n  packagerFactory.set(new MyPackagerFactory())\n}\n</code></pre>"},{"location":"publishing-aar/","title":"Publishing an AAR","text":"<p>The merged aar is included in a Gradle <code>SoftwareComponent</code> that you can publish using your plugin of choice. One component is created per library variant, using the same name as the variant.</p> <p>Integrating publishing with common publishing plugins is very simple, but direct access to the generated <code>aar</code> file is also available if a custom publishing solution is needed.</p> maven-publish <p>https://docs.gradle.org/current/userguide/publishing_maven.html</p> KotlinGroovy <pre><code>afterEvaluate {\n  publishing {\n    publications {\n      create&lt;MavenPublication&gt;(\"maven\") {\n        from(components[\"release\"])\n      }\n    }\n  }\n}\n</code></pre> <pre><code>afterEvaluate {\n  publishing {\n    publications {\n      maven(MavenPublication) {\n        from(components.release)\n      }\n    }\n  }\n}\n</code></pre> com.vanniktech.maven.publish <p>https://github.com/vanniktech/gradle-maven-publish-plugin</p> <p>You will need to specify the variant name of the merged aar you want to publish via a project property:</p> <pre><code>project.ext.set(\"ANDROID_VARIANT_TO_PUBLISH\", \"release\")\n</code></pre> Custom Publishing <p>If you have your own custom publishing step, you can reference the generated <code>aar</code> file as a property like so:</p> KotlinGroovy <pre><code>abstract class MyCustomPublishTask {\n  @get:InputFile\n  abstract val inputJar: RegularFileProperty\n\n  // ...\n}\n\ntasks.named&lt;MyCustomPublishTask&gt;(\"publish\") {\n  inputAar.set(tasks.named&lt;PackageAarTask&gt;(\"packageReleaseAar\").flatMap { it.outputAar })\n}\n</code></pre> <pre><code>abstract class MyCustomPublishTask {\n  @InputFile\n  abstract RegularFileProperty inputJar;\n\n  // ...\n}\n\ntasks.named(\"publish\", MyCustomPublishTask).configureEach {\n  inputAar.set(tasks.named(\"packageReleaseAar\", PackageAarTask).flatMap { it.outputAar })\n}\n</code></pre> <p>If using Android Gradle Plugin 8.0 or higher, make sure you've also set up variant publishing. Consult with the variant publication documentation if you need additional customization.</p> KotlinGroovy <pre><code>android {\n  publishing {\n    singleVariant(\"release\")\n  }\n}\n</code></pre> <pre><code>android {\n  publishing {\n    singleVariant \"release\"\n  }\n}\n</code></pre>"},{"location":"publishing-jar/","title":"Publishing a JAR","text":"<p>The merged jar is included in a Gradle <code>SoftwareComponent</code> that you can publish using your plugin of choice.</p> <p>Integrating publishing with common publishing plugins is very simple, but direct access to the generated <code>jar</code> file is also available if a custom publishing solution is needed.</p> maven-publish <p>https://docs.gradle.org/current/userguide/publishing_maven.html</p> KotlinGroovy <pre><code>afterEvaluate {\n  publishing {\n    publications {\n      create&lt;MavenPublication&gt;(\"maven\") {\n        from(components[\"java\"])\n      }\n    }\n  }\n}\n</code></pre> <pre><code>afterEvaluate {\n  publishing {\n    publications {\n      maven(MavenPublication) {\n        from(components.java)\n      }\n    }\n  }\n}\n</code></pre> com.vanniktech.maven.publish <p>https://github.com/vanniktech/gradle-maven-publish-plugin</p> <p>No configuration needed! Works right out of the box.</p> Custom Publishing <p>If you have your own custom publishing step, you can reference the generated <code>jar</code> file as a property like so:</p> KotlinGroovy <pre><code>abstract class MyCustomPublishTask {\n  @get:InputFile\n  abstract val inputJar: RegularFileProperty\n\n  // ...\n}\n\ntasks.named&lt;MyCustomPublishTask&gt;(\"publish\") {\n  inputJar.set(tasks.named&lt;PackageJarTask&gt;(\"packageJar\").flatMap { it.outputJar })\n}\n</code></pre> <pre><code>abstract class MyCustomPublishTask {\n  @InputFile\n  abstract RegularFileProperty inputJar;\n\n  // ...\n}\n\ntasks.named(\"publish\", MyCustomPublishTask).configureEach {\n  inputJar.set(tasks.named(\"packageJar\", PackageJarTask).flatMap { it.outputJar })\n}\n</code></pre>"},{"location":"shading/","title":"Shading","text":"<p>When you embed dependencies directly into your published output, you are attributing these classes to your published artifact, not the one they originally came from. As a result, if a project consumes your published output in addition to any external dependencies you are embedding, it's likely that compilation may fail due to duplicate classes!</p> <p>This can be mitigated by shading classes you are embedding. Shading allows you to rename package and classes, transforming the bytecode during the packaging step. Shading rules can be specified via the <code>aaraar</code> extension, and can be applied universally or scoped to a particular set of projects or dependencies.</p>"},{"location":"shading/#rules","title":"Rules","text":"<p>Classes can be specified by matching against a pattern that supports two wildcard types:</p> <ul> <li><code>*</code> will match a single package component.</li> <li><code>**</code> will match against the remainder of any valid fully-qualified class name.</li> </ul> <p>For class renames, the replacement string is a class name which can reference the substrings matched by the wildcards. A numbered reference is available for every wildcard in the pattern, starting from left to right: <code>@1</code>, <code>@2</code>, etc. A special <code>@0</code> reference contains the entire matched class name.</p> <p>Exclusions for Android modules configured via <code>packaging</code> to delete resource files will also be respected:</p> <pre><code>android {\n  packagingOptions {\n    resources {\n      excludes += \"**/module-info.class\"\n    }\n  }\n}\n</code></pre>"},{"location":"shading/#scopes","title":"Scopes","text":"<p>There are multiple ways to specify a scope for shading rules:</p> <ul> <li>All: Applies to all classes and resource files in the merged file.</li> <li>Project: Applies to a single project (eg: <code>project(\":internal\")</code>)</li> <li>Group: Applies to any artifact within a dependency group (eg: <code>io.reactivex.rxjava3</code>)</li> <li>Module: Applies to any version of a dependency (eg: <code>io.reactivex.rxjava3:rxjava</code>)</li> <li>Dependency: Applies to a single version of a dependency (eg: <code>io.reactivex.rxjava3:rxjava:3.1.8</code>)</li> <li>Files: Applies to a file, set of files, or an entire file tree (eg: <code>fileTree(\"libs\")</code>)</li> </ul> <p>Rules can be applied to one or more matching scope.</p>"},{"location":"shading/#examples","title":"Examples","text":"<p>Shading an embedded external dependency to prevent conflicts:</p> KotlinGroovy <pre><code>aaraar {\n  shading {\n    createRule(forProject(path) and forGroup(\"io.reactivex.rxjava3\")) {\n      rename(\"io.reactivex.**\", \"shaded.io.reactivex.@1\")\n    }\n  }\n}\n</code></pre> <pre><code>aaraar {\n  shading {\n    createRule([forProject(path), forGroup(\"io.reactivex.rxjava3\")]) {\n      it.rename \"io.reactivex.**\", \"shaded.io.reactivex.@1\"\n    }\n  }\n}\n</code></pre> <p>Adding a prefix to internal sources to reinforce usage type:</p> KotlinGroovy <pre><code>aaraar {\n  shading {\n    createRule(forProject(path) and forProject(project(\":internal\"))) {\n      addPrefix(\"internal.\")\n    }\n  }\n}\n</code></pre> <pre><code>aaraar {\n  shading {\n    createRule([forProject(path), forProject(project(\":internal\"))]) {\n      it.addPrefix \"internal.\"\n    }\n  }\n}\n</code></pre> <p>Removing all internal debug classes from production code:</p> KotlinGroovy <pre><code>aaraar {\n  shading {\n    createRule {\n      delete(\"com.myapp.debug.**\")\n      delete(\"com.myapp.LocalEnvironmentKeyProvider\")\n    }\n  }\n}\n</code></pre> <pre><code>aaraar {\n  shading {\n    createRule {\n      it.delete \"com.myapp.debug.**\"\n      it.delete \"com.myapp.LocalEnvironmentKeyProvider\"\n    }\n  }\n}\n</code></pre> <p>Removing an unused feature from an external dependency:</p> KotlinGroovy <pre><code>aaraar {\n  shading {\n    createRule(forProject(path) and forDependency(libs.bouncycastle.prov)) {\n      delete(\"org.bouncycastle.x509.**\")\n    }\n  }\n}\n</code></pre> <pre><code>aaraar {\n  shading {\n    createRule([forProject(path), forDependency(libs.bouncycastle.prov)]) {\n      it.delete \"org.bouncycastle.x509.**\"\n    }\n  }\n}\n</code></pre> <p>Renaming classes from static jar files:</p> KotlinGroovy <pre><code>aaraar {\n  shading {\n    createRule(forProject(path) and forFiles(fileTree(\"libs/debug/\") { include(\"*.jar\") })) {\n      rename(\"com.**\", \"com.debug.@1\")\n    }\n  }\n}\n</code></pre> <pre><code>aaraar {\n  shading {\n    createRule([forProject(path), forFiles(fileTree(dir: \"libs/debug/\", include: [\"*.jar\"]))]) {\n      it.rename \"com.**\", \"com.debug.@1\"\n    }\n  }\n}\n</code></pre>"}]}